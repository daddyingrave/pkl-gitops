/// Bucket is the Schema for the buckets API.
///
/// This module was generated from the CustomResourceDefinition at
/// <https://raw.githubusercontent.com/fluxcd/source-controller/refs/tags/v1.4.1/config/crd/bases/source.toolkit.fluxcd.io_buckets.yaml>.
module io.fluxcd.toolkit.source.v1.Bucket

extends "package://pkg.pkl-lang.org/pkl-k8s/k8s@1.1.1#/K8sResource.pkl"

import "package://pkg.pkl-lang.org/pkl-k8s/k8s@1.1.1#/apimachinery/pkg/apis/meta/v1/ObjectMeta.pkl"

fixed apiVersion: "source.toolkit.fluxcd.io/v1"

fixed kind: "Bucket"

/// Standard object's metadata.
///
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>.
metadata: ObjectMeta?

/// BucketSpec specifies the required configuration to produce an Artifact for an object storage bucket.
spec: Spec?

/// BucketStatus records the observed state of a Bucket.
///
/// Default if undefined: `{ ["observedGeneration"] = -1 }`
status: Status?

/// BucketSpec specifies the required configuration to produce an Artifact for an object storage bucket.
class Spec {
  /// BucketName is the name of the object storage bucket.
  bucketName: String

  /// CertSecretRef can be given the name of a Secret containing either or both of
  ///
  /// - a PEM-encoded client certificate (`tls.crt`) and private key (`tls.key`); - a PEM-encoded CA
  /// certificate (`ca.crt`)
  ///
  /// and whichever are supplied, will be used for connecting to the bucket. The client cert and key are
  /// useful if you are authenticating with a certificate; the CA cert is useful if you are using a
  /// self-signed server certificate. The Secret must be of type `Opaque` or `kubernetes.io/tls`.
  ///
  /// This field is only supported for the `generic` provider.
  certSecretRef: CertSecretRef?

  /// Endpoint is the object storage address the BucketName is located at.
  endpoint: String

  /// Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as
  /// .gitignore). If not provided, a default will be used, consult the documentation for your version to
  /// find out what those are.
  ignore: String?

  /// Insecure allows connecting to a non-TLS HTTP Endpoint.
  insecure: Boolean?

  /// Interval at which the Bucket Endpoint is checked for updates. This interval is approximate and may
  /// be subject to jitter to ensure efficient use of resources.
  interval: String(matches(Regex(#"^([0-9]+(\.[0-9]+)?(ms|s|m|h))+$"#)))

  /// Prefix to use for server-side filtering of files in the Bucket.
  prefix: String?

  /// Provider of the object storage bucket. Defaults to 'generic', which expects an S3 (API) compatible
  /// object storage.
  ///
  /// Default if undefined: `"generic"`
  provider: ("generic"|"aws"|"gcp"|"azure")?

  /// ProxySecretRef specifies the Secret containing the proxy configuration to use while communicating
  /// with the Bucket server.
  proxySecretRef: ProxySecretRef?

  /// Region of the Endpoint where the BucketName is located in.
  region: String?

  /// SecretRef specifies the Secret containing authentication credentials for the Bucket.
  secretRef: SecretRef?

  /// STS specifies the required configuration to use a Security Token Service for fetching temporary
  /// credentials to authenticate in a Bucket provider.
  ///
  /// This field is only supported for the `aws` and `generic` providers.
  sts: Sts?

  /// Suspend tells the controller to suspend the reconciliation of this Bucket.
  suspend: Boolean?

  /// Timeout for fetch operations, defaults to 60s.
  ///
  /// Default if undefined: `"60s"`
  timeout: String(matches(Regex(#"^([0-9]+(\.[0-9]+)?(ms|s|m))+$"#)))?
}

/// CertSecretRef can be given the name of a Secret containing either or both of
///
/// - a PEM-encoded client certificate (`tls.crt`) and private key (`tls.key`); - a PEM-encoded CA
/// certificate (`ca.crt`)
///
/// and whichever are supplied, will be used for connecting to the bucket. The client cert and key are
/// useful if you are authenticating with a certificate; the CA cert is useful if you are using a
/// self-signed server certificate. The Secret must be of type `Opaque` or `kubernetes.io/tls`.
///
/// This field is only supported for the `generic` provider.
class CertSecretRef {
  /// Name of the referent.
  name: String
}

/// ProxySecretRef specifies the Secret containing the proxy configuration to use while communicating
/// with the Bucket server.
class ProxySecretRef {
  /// Name of the referent.
  name: String
}

/// SecretRef specifies the Secret containing authentication credentials for the Bucket.
class SecretRef {
  /// Name of the referent.
  name: String
}

/// STS specifies the required configuration to use a Security Token Service for fetching temporary
/// credentials to authenticate in a Bucket provider.
///
/// This field is only supported for the `aws` and `generic` providers.
class Sts {
  /// CertSecretRef can be given the name of a Secret containing either or both of
  ///
  /// - a PEM-encoded client certificate (`tls.crt`) and private key (`tls.key`); - a PEM-encoded CA
  /// certificate (`ca.crt`)
  ///
  /// and whichever are supplied, will be used for connecting to the STS endpoint. The client cert and
  /// key are useful if you are authenticating with a certificate; the CA cert is useful if you are using
  /// a self-signed server certificate. The Secret must be of type `Opaque` or `kubernetes.io/tls`.
  ///
  /// This field is only supported for the `ldap` provider.
  certSecretRef: StsCertSecretRef?

  /// Endpoint is the HTTP/S endpoint of the Security Token Service from where temporary credentials will
  /// be fetched.
  endpoint: String(matches(Regex("^(http|https)://.*$")))

  /// Provider of the Security Token Service.
  provider: "aws"|"ldap"

  /// SecretRef specifies the Secret containing authentication credentials for the STS endpoint. This
  /// Secret must contain the fields `username` and `password` and is supported only for the `ldap`
  /// provider.
  secretRef: StsSecretRef?
}

/// CertSecretRef can be given the name of a Secret containing either or both of
///
/// - a PEM-encoded client certificate (`tls.crt`) and private key (`tls.key`); - a PEM-encoded CA
/// certificate (`ca.crt`)
///
/// and whichever are supplied, will be used for connecting to the STS endpoint. The client cert and key
/// are useful if you are authenticating with a certificate; the CA cert is useful if you are using a
/// self-signed server certificate. The Secret must be of type `Opaque` or `kubernetes.io/tls`.
///
/// This field is only supported for the `ldap` provider.
class StsCertSecretRef {
  /// Name of the referent.
  name: String
}

/// SecretRef specifies the Secret containing authentication credentials for the STS endpoint. This
/// Secret must contain the fields `username` and `password` and is supported only for the `ldap`
/// provider.
class StsSecretRef {
  /// Name of the referent.
  name: String
}

/// BucketStatus records the observed state of a Bucket.
///
/// Default if undefined: `{ ["observedGeneration"] = -1 }`
class Status {
  /// Artifact represents the last successful Bucket reconciliation.
  artifact: Artifact?

  /// Conditions holds the conditions for the Bucket.
  conditions: Listing<Condition>?

  /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of
  /// the annotation value can be detected.
  lastHandledReconcileAt: String?

  /// ObservedGeneration is the last observed generation of the Bucket object.
  observedGeneration: Int?

  /// ObservedIgnore is the observed exclusion patterns used for constructing the source artifact.
  observedIgnore: String?

  /// URL is the dynamic fetch link for the latest Artifact. It is provided on a "best effort" basis, and
  /// using the precise BucketStatus.Artifact data is recommended.
  url: String?
}

/// Artifact represents the last successful Bucket reconciliation.
class Artifact {
  /// Digest is the digest of the file in the form of '<algorithm>:<checksum>'.
  digest: String(matches(Regex("^[a-z0-9]+(?:[.+_-][a-z0-9]+)*:[a-zA-Z0-9=_-]+$")))?

  /// LastUpdateTime is the timestamp corresponding to the last update of the Artifact.
  lastUpdateTime: String

  /// Metadata holds upstream information such as OCI annotations.
  metadata: Mapping<String, String>?

  /// Path is the relative file path of the Artifact. It can be used to locate the file in the root of
  /// the Artifact storage on the local file system of the controller managing the Source.
  path: String

  /// Revision is a human-readable identifier traceable in the origin source system. It can be a Git
  /// commit SHA, Git tag, a Helm chart version, etc.
  revision: String

  /// Size is the number of bytes in the file.
  size: Int?

  /// URL is the HTTP address of the Artifact as exposed by the controller managing the Source. It can be
  /// used to retrieve the Artifact for consumption, e.g. by another controller applying the Artifact
  /// contents.
  url: String
}

/// Condition contains details for one aspect of the current state of this API Resource.
class Condition {
  /// lastTransitionTime is the last time the condition transitioned from one status to another. This
  /// should be when the underlying condition changed. If that is not known, then using the time when the
  /// API field changed is acceptable.
  lastTransitionTime: String

  /// message is a human readable message indicating details about the transition. This may be an empty
  /// string.
  message: String(length <= 32768)

  /// observedGeneration represents the .metadata.generation that the condition was set based upon. For
  /// instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration
  /// is 9, the condition is out of date with respect to the current state of the instance.
  observedGeneration: Int(isPositive)?

  /// reason contains a programmatic identifier indicating the reason for the condition's last
  /// transition. Producers of specific condition types may define expected values and meanings for this
  /// field, and whether the values are considered a guaranteed API. The value should be a CamelCase
  /// string. This field may not be empty.
  reason: String(length.isBetween(1, 1024), matches(Regex("^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$")))

  /// status of the condition, one of True, False, Unknown.
  status: "True"|"False"|"Unknown"

  /// type of condition in CamelCase or in foo.example.com/CamelCase.
  type: String(length <= 316, matches(Regex(#"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"#)))
}
